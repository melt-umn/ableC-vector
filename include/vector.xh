#include <string.xh>
#include <gc.h>

#include <string.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
//#include <limits.h>

#ifndef _VECTOR_XH
#define _VECTOR_XH

struct _vector_info {
  size_t length;
  size_t capacity;
  size_t elem_size;
};

template<a>
struct __attribute__((module("edu:umn:cs:melt:exts:ableC:vector:vector"))) _vector_s {
  struct _vector_info *_info;
  a **_contents;
};

// Check whether an index is valid for given vector info
template<a>
static void _check_index_vector(vector<a> v, size_t idx) {
  if (idx >= v.length || idx < 0) {
    fprintf(stderr, "Vector index out of bounds: length %lu, index %lu\n", v.length, idx);
    exit(1);
  }
  if (v._contents == NULL) {
    fprintf(stderr, "Cannot access uninitialized vector\n");
    exit(1);
  }
}

// Increase the length of a vector to new_size, updating the given info and contents pointers
template<a>
static void _resize_vector(vector<a> v, size_t new_length) {
  v._info->length = new_length;
  if (new_length > v.capacity) {
    v._info->capacity = new_length * 2;
    *v._contents = GC_realloc(*v._contents, v.elem_size * v.capacity);
  }
}

template<a>
static vector<a> _new_vector(size_t length) {
  struct _vector_info *info = GC_malloc(sizeof(struct _vector_info));
  info->length = length;
  info->capacity = length * 2;
  info->elem_size = sizeof(a);
  a **contents = GC_malloc(sizeof(a*));
  *contents = GC_malloc(sizeof(a) * info->capacity);
  return (vector <a>){info, contents};
}

template<a>
static vector<a> _copy_vector(vector<a> v) {
  struct _vector_info *info = GC_malloc(sizeof(struct _vector_info));
  *info = *v._info;
  a **contents = GC_malloc(sizeof(a*));
  *contents = GC_malloc(v.elem_size * v.capacity);
  
  for (size_t i = 0; i < v.length; i++) {
    (*contents)[i] = v[i];
  }
  
  return (vector<a>){info, contents};
}

template<a>
static void _append_vector(vector<a> v, a elem) {
  inst _resize_vector<a>(v, v.length + 1);
  (*v._contents)[v.length - 1] = elem;
}

template<a>
static void _insert_vector(vector<a> v, size_t idx, a elem) {
  inst _resize_vector<a>(v, v.length + 1);
  
  for (size_t i = v.length - 1; i > idx; i--) {
    v[i] = v[i - 1];
  }
  v[idx] = elem;
}

template<a>
static void _extend_vector(vector<a> vec1, vector<a> vec2) {
  size_t vec1_length = vec1.length;
  inst _resize_vector<a>(vec1, vec1.length + vec2.length);

  for (size_t i = 0; i < vec2.length; i++) {
    (*vec1._contents)[i + vec1_length] = vec2[i];
  }
}

template<a>
static bool _eq_vector(vector<a> vec1, vector<a> vec2) {
  if (vec1.length != vec2.length)
    return 0;

  for (size_t i = 0; i < vec1.length; i++) {
    if (vec1[i] != vec2[i])
      return 0;
  }
  
  return 1;
}

template<a>
static string _show_vector(vector<a> v) {
  if (v.length == 0)
    return str("[]");
    
  string result = "[" + show(v[0]);
  
  for (size_t i = 1; i < v.length; i++) {
    result += ", " + show(v[i]);
  }
  
  return result + "]";
}

#endif
