#include <string.xh>
#include <gc.h>

#include <string.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
//#include <limits.h>

#ifndef _VECTOR_XH
#define _VECTOR_XH

template<a>
struct _vector_s {
  size_t length;
  size_t capacity;
  a *contents;
};

// Check whether an index is valid for a given vector
template<a>
static void _check_index_vector(vector<a> v, size_t idx) {
  if ((inst _vector_s<a> *)v == NULL || ((inst _vector_s<a> *)v)->contents == NULL) {
    fprintf(stderr, "Cannot access uninitialized vector\n");
    exit(1);
  }
  if (idx >= v.length || idx < 0) {
    fprintf(stderr, "Vector index out of bounds: length %lu, index %lu\n", v.length, idx);
    exit(1);
  }
}

// Modify the length of a vector to new_length
template<a>
static void resize_vector(vector<a> v, size_t new_length) {
  ((inst _vector_s<a> *)v)->length = new_length;
  if (new_length > v.capacity) {
    ((inst _vector_s<a> *)v)->capacity = new_length * 2;
    ((inst _vector_s<a> *)v)->contents =
      GC_realloc(((inst _vector_s<a> *)v)->contents, sizeof(a) * v.capacity);
  }
}

// Create a new vector with the given length
template<a>
static vector<a> new_vector(size_t length) {
  size_t capacity = length * 2;
  inst _vector_s<a> *result = GC_malloc(sizeof(inst _vector_s<a>));
  result->length = length;
  result->capacity = capacity;
  result->contents = GC_malloc(sizeof(a) * capacity);
  return (vector<a>)result;
}

// Make a shallow copy of a vector
template<a>
static vector<a> copy_vector(vector<a> v) {
  vector<a> result = vec<a>(v.length);
  for (size_t i = 0; i < v.length; i++) {
    // Note that this uses overloaded =
    result[i] = v[i];
  }
  return result;
}

// Append an element to the end of a vector
template<a>
static void append_vector(vector<a> v, a elem) {
  inst resize_vector<a>(v, v.length + 1);
  v[v.length - 1] = elem;
}

// Insert an element at an index into a vector
template<a>
static void insert_vector(vector<a> v, size_t idx, a elem) {
  inst resize_vector<a>(v, v.length + 1);
  for (size_t i = v.length - 1; i > idx; i--) {
    // Note that this uses overloaded =
    v[i] = v[i - 1];
  }
  v[idx] = elem;
}

// Append all the elements of another vector to a vector
template<a>
static void extend_vector(vector<a> v1, vector<a> v2) {
  size_t v1_length = v1.length;
  size_t v2_length = v2.length;
  inst resize_vector<a>(v1, v1_length + v2_length);
  for (size_t i = 0; i < v2_length; i++) {
    // Note that this uses overloaded =
    v1[i + v1_length] = v2[i];
  }
}

// Check if two vectors are equal
template<a>
static bool equals_vector(vector<a> v1, vector<a> v2) {
  if (v1.length != v2.length)
    return false;

  for (size_t i = 0; i < v1.length; i++) {
    // Note that this uses overloaded !=
    if (v1[i] != v2[i])
      return false;
  }
  
  return true;
}

// Convert a vector to a string representation
template<a>
static string show_vector(vector<a> v) {
  if (v.length == 0)
    return str("[]");

  string result = "[" + show(v[0]);
  
  for (size_t i = 1; i < v.length; i++) {
    result += ", " + show(v[i]);
  }
  
  return result + "]";
}

#endif
